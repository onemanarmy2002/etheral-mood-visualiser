<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotional Void: Neon Luminous HUD</title>
    <style>
        :root {
            --bg-color: #020202;
            --font-main: 'Inter', system-ui, -apple-system, sans-serif;
            --ui-opacity: 0.45; 
            --accent: #fff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--accent);
            font-family: var(--font-main);
        }

        canvas {
            display: block;
        }

        /* UI Containers - The Four Edges */
        .edge-ui {
            position: absolute;
            z-index: 100;
            display: flex;
            pointer-events: auto;
            mix-blend-mode: difference; /* Difference works better across all exposures for UI */
        }

        #left-ribbon { top: 0; left: 0; height: 100%; width: 50px; flex-direction: column; padding: 60px 0; }
        #right-ribbon { top: 0; right: 0; height: 100%; width: 50px; flex-direction: column-reverse; padding: 60px 0; }
        #bottom-ribbon { bottom: 0; left: 0; width: 100%; height: 50px; flex-direction: row; padding: 0 80px; }
        #top-ribbon { top: 0; left: 0; width: 100%; height: 50px; flex-direction: row; padding: 0 80px; }

        /* Edge Labels - Descriptive Headers */
        .edge-header {
            position: absolute;
            font-size: 9px;
            letter-spacing: 4px;
            text-transform: uppercase;
            opacity: 0.4; 
            color: #fff;
            pointer-events: none;
            z-index: 110;
            font-weight: 700;
            transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1);
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            mix-blend-mode: difference;
        }

        #left-ribbon:hover ~ .label-left,
        #right-ribbon:hover ~ .label-right,
        #top-ribbon:hover ~ .label-top,
        #bottom-ribbon:hover ~ .label-bottom { 
            opacity: 1; 
            letter-spacing: 8px;
        }

        .label-top { top: 60px; left: 50%; transform: translateX(-50%); }
        .label-bottom { bottom: 60px; left: 50%; transform: translateX(-50%); }
        .label-left { left: 60px; top: 50%; transform: translateY(-50%) rotate(-90deg); transform-origin: center left; }
        .label-right { right: 60px; top: 50%; transform: translateY(-50%) rotate(90deg); transform-origin: center right; }

        .segment {
            flex: 1;
            background: currentColor; 
            opacity: var(--ui-opacity);
            transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            overflow: visible; 
            box-shadow: 
                0 0 5px #fff,
                0 0 10px currentColor;
            filter: brightness(1.2);
        }

        .segment::before {
            content: '';
            position: absolute;
            background: #fff;
            opacity: 0;
            transition: opacity 0.2s;
            mix-blend-mode: overlay;
        }

        #left-ribbon .segment::before, #right-ribbon .segment::before { width: 100%; height: 0%; bottom: 0; left: 0; }
        #top-ribbon .segment::before, #bottom-ribbon .segment::before { height: 100%; width: 0%; left: 0; top: 0; }

        .segment.charging::before {
            opacity: 1;
            transition: width 1s linear, height 1s linear, opacity 0.2s;
            box-shadow: 0 0 20px #fff;
        }
        #left-ribbon .segment.charging::before, #right-ribbon .segment.charging::before { height: 100%; }
        #top-ribbon .segment.charging::before, #bottom-ribbon .segment.charging::before { width: 100%; }

        #left-ribbon .segment, #right-ribbon .segment { width: 3px; margin: 3px auto; }
        #bottom-ribbon .segment, #top-ribbon .segment { height: 3px; margin: auto 3px; }

        .edge-ui:hover .segment { opacity: 0.6; }
        
        .segment:hover { 
            opacity: 1 !important; 
            z-index: 10;
            filter: brightness(1.8);
            box-shadow: 
                0 0 10px #fff,
                0 0 30px currentColor;
        }

        #left-ribbon .segment:hover { width: 40px; transform: translateX(5px) scaleY(1.05); }
        #right-ribbon .segment:hover { width: 40px; transform: translateX(-5px) scaleY(1.05); }
        #bottom-ribbon .segment:hover { height: 35px; transform: translateY(-5px) scaleX(1.05); }
        #top-ribbon .segment:hover { height: 35px; transform: translateY(5px) scaleX(1.05); }

        .segment.active { 
            opacity: 1; 
            box-shadow: 
                0 0 10px #fff,
                0 0 25px currentColor;
            filter: brightness(1.6);
            animation: breathe 2s infinite ease-in-out;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); filter: brightness(1.5); box-shadow: 0 0 15px #fff, 0 0 25px currentColor; }
            50% { transform: scale(1.1); filter: brightness(2.5); box-shadow: 0 0 25px #fff, 0 0 50px currentColor; }
        }

        .label {
            position: absolute;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 2.5px;
            text-transform: uppercase;
            white-space: nowrap;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            pointer-events: none;
            background: rgba(255, 255, 255, 0.15);
            padding: 6px 14px;
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }

        #left-ribbon .label { left: 45px; transform: translateX(-15px); }
        #right-ribbon .label { right: 45px; transform: translateX(15px); }
        #bottom-ribbon .label { top: -45px; transform: translateY(15px); }
        #top-ribbon .label { bottom: -45px; transform: translateY(-15px); }

        .segment:hover .label { opacity: 1; transform: translate(0, 0); }

        #status-display {
            position: absolute;
            bottom: 60px;
            right: 80px;
            text-align: right;
            pointer-events: none;
            z-index: 50;
            color: #fff;
            mix-blend-mode: difference;
        }

        #current-emotion {
            display: block;
            font-size: 42px;
            font-weight: 100;
            letter-spacing: 14px;
            margin-bottom: 6px;
            text-transform: uppercase;
            transition: color 0.5s;
        }

        .info-sub {
            font-size: 9px;
            letter-spacing: 3.5px;
            opacity: 0.8;
            text-transform: uppercase;
            font-weight: 400;
        }

        .vignette {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.5) 100%);
            pointer-events: none;
            mix-blend-mode: multiply;
        }
    </style>
</head>
<body>

    <canvas id="voidCanvas"></canvas>
    <div class="vignette"></div>
    
    <div id="status-display">
        <span id="current-emotion">JOY</span>
        <span class="info-sub" id="mode-info">Initialising System...</span>
    </div>

    <div id="left-ribbon" class="edge-ui"></div>
    <div id="right-ribbon" class="edge-ui"></div>
    <div id="bottom-ribbon" class="edge-ui"></div>
    <div id="top-ribbon" class="edge-ui"></div>

    <!-- Edge Headers -->
    <div class="edge-header label-left">Emotional Spectrum</div>
    <div class="edge-header label-right">Luminance / Exposure</div>
    <div class="edge-header label-top">Acoustic Intensity</div>
    <div class="edge-header label-bottom">Prism Refraction</div>

    <script>
        const canvas = document.getElementById('voidCanvas');
        const ctx = canvas.getContext('2d');
        const emotionDisplay = document.getElementById('current-emotion');
        const modeInfo = document.getElementById('mode-info');

        let width, height;
        let particles = [];
        let currentMood = 'joy';
        let exposureLevel = 0;
        let prismMode = 'standard';
        let globalVolume = 0.5;
        let mouse = { x: -1000, y: -1000 };

        // --- Transition State (Lerp targets) ---
        const lerpState = {
            bg: { r: 2, g: 2, b: 2 },
            targetBg: { r: 2, g: 2, b: 2 },
            contrast: 100,
            targetContrast: 100,
            brightness: 100,
            targetBrightness: 100,
            lerpSpeed: 0.05
        };

        const lerp = (start, end, amt) => start + (end - start) * amt;

        // --- Audio Engine ---
        let audioCtx, mainGain, synthOsc, initialized = false;

        async function initAudio() {
            if (initialized) {
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                return;
            }
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                mainGain = audioCtx.createGain();
                mainGain.gain.setValueAtTime(0, audioCtx.currentTime);
                mainGain.connect(audioCtx.destination);
                
                synthOsc = audioCtx.createOscillator();
                synthOsc.type = 'sine';
                
                const lfo = audioCtx.createOscillator();
                const lfoGain = audioCtx.createGain();
                lfo.frequency.value = 0.5;
                lfoGain.gain.value = 8;
                lfo.connect(lfoGain);
                lfoGain.connect(synthOsc.frequency);
                
                synthOsc.connect(mainGain);
                synthOsc.start();
                lfo.start();

                initialized = true;
                updateAudioMood();
            } catch (e) { console.warn("Audio Context blocked."); }
        }

        function updateAudioMood() {
            if (!initialized || !audioCtx) return;
            const mood = moods[currentMood];
            const freq = mood.baseFreq || 200;
            const targetVol = (mood.volume || 0.05) * globalVolume;
            
            synthOsc.frequency.exponentialRampToValueAtTime(freq, audioCtx.currentTime + 0.8);
            mainGain.gain.linearRampToValueAtTime(targetVol, audioCtx.currentTime + 0.8);
        }

        const moods = {
            joy: { name: 'Joy', color: '#ffcc33', shape: 'circle', speed: 1.2, count: 80, friction: 0.98, gravity: -0.01, chaos: 0.1, mouse: 0.05, connect: true, baseFreq: 440, volume: 0.04 },
            melancholy: { name: 'Melancholy', color: '#4466ff', shape: 'blob', speed: 0.2, count: 50, friction: 0.99, gravity: 0.02, chaos: 0.02, mouse: 0.01, connect: true, baseFreq: 110, volume: 0.07 },
            rage: { name: 'Rage', color: '#ff3311', shape: 'shard', speed: 3.8, count: 120, friction: 0.94, gravity: 0, chaos: 1.6, mouse: -0.6, connect: false, baseFreq: 70, volume: 0.1 },
            serenity: { name: 'Serenity', color: '#33ffcc', shape: 'line', speed: 0.5, count: 65, friction: 0.995, gravity: 0, chaos: 0.01, mouse: 0.03, connect: true, baseFreq: 220, volume: 0.03 }
        };

        const exposures = [
            { name: 'Abyssal', bg: {r: 2, g: 2, b: 2}, brightness: 80, contrast: 100 },
            { name: 'Dim', bg: {r: 26, g: 26, b: 26}, brightness: 100, contrast: 100 },
            { name: 'Bright', bg: {r: 210, g: 210, b: 210}, brightness: 120, contrast: 110 },
            { name: 'Solar', bg: {r: 255, g: 255, b: 255}, brightness: 150, contrast: 130 }
        ];

        const prisms = {
            standard: { name: 'Standard', filter: '' },
            highVis: { name: 'High Contrast', filter: 'contrast(250%) saturate(150%)' },
            inverted: { name: 'Negative', filter: 'invert(100%)' },
            mono: { name: 'Monochrome', filter: 'grayscale(100%)' }
        };

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if (particles.length === 0) initParticles();
        }

        class Particle {
            constructor() { this.init(); }
            init() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.size = Math.random() * 3 + 1;
                this.angle = Math.random() * Math.PI * 2;
                this.spin = (Math.random() - 0.5) * 0.1;
                this.curSpeed = 0; 
            }
            update(m) {
                this.curSpeed += (m.speed - this.curSpeed) * 0.05;
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const d2 = dx*dx + dy*dy; 
                if (d2 < 62500) { 
                    const force = (250 - Math.sqrt(d2)) / 250;
                    this.vx += dx * force * m.mouse * 0.1;
                    this.vy += dy * force * m.mouse * 0.1;
                }
                this.x += this.vx * this.curSpeed;
                this.y += this.vy * this.curSpeed;
                this.vx *= m.friction;
                this.vy *= m.friction;
                this.vy += m.gravity; 
                this.vx += (Math.random() - 0.5) * m.chaos;
                this.vy += (Math.random() - 0.5) * m.chaos;
                this.angle += this.spin * (this.curSpeed * 0.5);

                if (this.x < -100) this.x = width + 100;
                if (this.x > width + 100) this.x = -100;
                if (this.y < -100) this.y = height + 100;
                if (this.y > height + 100) this.y = -100;
            }
            draw(m) {
                const bgLuminance = (lerpState.bg.r + lerpState.bg.g + lerpState.bg.b) / 3;
                const isBright = bgLuminance > 180;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Neon glow for particles
                // If the background is too bright, we switch to a "depth shadow" to keep it visible
                ctx.shadowBlur = isBright ? 5 : 15;
                ctx.shadowColor = isBright ? 'rgba(0,0,0,0.4)' : m.color;
                
                ctx.beginPath();
                ctx.fillStyle = m.color;
                
                const expOpacity = lerpState.brightness / 150;
                ctx.globalAlpha = Math.min(1.0, expOpacity + 0.3);

                if (m.shape === 'circle') ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
                else if (m.shape === 'shard') { ctx.moveTo(0, -this.size * 3); ctx.lineTo(this.size, this.size); ctx.lineTo(-this.size, this.size); ctx.closePath(); }
                else if (m.shape === 'line') ctx.rect(-this.size * 4, -0.5, this.size * 8, 1);
                else if (m.shape === 'blob') { ctx.globalAlpha *= 0.3; ctx.shadowBlur = isBright ? 10 : 25; ctx.arc(0, 0, this.size * 8, 0, Math.PI * 2); }
                
                ctx.fill();
                
                // Add an extra thin stroke on bright backgrounds for definition
                if (isBright) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < 200; i++) particles.push(new Particle());
        }

        function setMood(key) {
            currentMood = key;
            initAudio();
            updateAudioMood();
            emotionDisplay.innerText = moods[key].name;
            updateUIActiveStates();
        }

        function setExposure(idx) {
            exposureLevel = idx;
            initAudio();
            const exp = exposures[idx];
            lerpState.targetBg = exp.bg;
            lerpState.targetBrightness = exp.brightness;
            lerpState.targetContrast = exp.contrast;
            updateStatusInfo();
            updateUIActiveStates();
        }

        function setPrism(key) {
            prismMode = key;
            initAudio();
            updateStatusInfo();
            updateUIActiveStates();
        }

        function setVolume(val) {
            globalVolume = val;
            initAudio();
            updateAudioMood();
            updateStatusInfo();
            updateUIActiveStates();
        }

        function updateStatusInfo() {
            const volPct = Math.round(globalVolume * 100);
            modeInfo.innerText = `Exposure: ${exposures[exposureLevel].name} | Prism: ${prisms[prismMode].name} | Volume: ${volPct}%`;
        }

        function updateUIActiveStates() {
            document.querySelectorAll('.segment').forEach(s => {
                const isMood = s.dataset.mood === currentMood;
                const isExp = s.dataset.exp !== undefined && parseInt(s.dataset.exp) === exposureLevel;
                const isPrism = s.dataset.prism === prismMode;
                const isVol = s.dataset.vol !== undefined && parseFloat(s.dataset.vol) <= globalVolume;
                s.classList.toggle('active', isMood || isExp || isPrism || isVol);
            });
        }

        function createUI() {
            const left = document.getElementById('left-ribbon');
            Object.keys(moods).forEach(key => {
                const seg = createSegment(key, moods[key].name, 'mood', moods[key].color, true);
                seg.addEventListener('triggered', () => setMood(key));
                left.appendChild(seg);
            });

            const right = document.getElementById('right-ribbon');
            exposures.forEach((exp, i) => {
                const seg = createSegment(i, exp.name, 'exp', '#fff', true);
                seg.addEventListener('triggered', () => setExposure(i));
                right.appendChild(seg);
            });

            const bottom = document.getElementById('bottom-ribbon');
            Object.keys(prisms).forEach(key => {
                const seg = createSegment(key, prisms[key].name, 'prism', '#fff', true);
                seg.addEventListener('triggered', () => setPrism(key));
                bottom.appendChild(seg);
            });

            const top = document.getElementById('top-ribbon');
            for(let i=0; i<=10; i++) {
                const volVal = i / 10;
                const seg = createSegment(volVal, `${i*10}%`, 'vol', '#fff', false);
                seg.addEventListener('mouseenter', () => setVolume(volVal));
                top.appendChild(seg);
            }
            updateUIActiveStates();
        }

        function createSegment(val, labelTxt, type, color, useTimer) {
            const div = document.createElement('div');
            div.className = 'segment';
            div.dataset[type] = val;
            if (color) div.style.color = color; 
            
            const label = document.createElement('span');
            label.className = 'label';
            label.innerText = labelTxt;
            div.appendChild(label);

            if (useTimer) {
                let timer = null;
                div.addEventListener('mouseenter', () => {
                    div.classList.add('charging');
                    timer = setTimeout(() => {
                        div.dispatchEvent(new CustomEvent('triggered'));
                        div.classList.remove('charging');
                    }, 1000); 
                });
                div.addEventListener('mouseleave', () => {
                    div.classList.remove('charging');
                    if (timer) clearTimeout(timer);
                });
            }

            return div;
        }

        function animate() {
            lerpState.bg.r = lerp(lerpState.bg.r, lerpState.targetBg.r, lerpState.lerpSpeed);
            lerpState.bg.g = lerp(lerpState.bg.g, lerpState.targetBg.g, lerpState.lerpSpeed);
            lerpState.bg.b = lerp(lerpState.bg.b, lerpState.targetBg.b, lerpState.lerpSpeed);
            lerpState.brightness = lerp(lerpState.brightness, lerpState.targetBrightness, lerpState.lerpSpeed);
            lerpState.contrast = lerp(lerpState.contrast, lerpState.targetContrast, lerpState.lerpSpeed);

            const bgR = Math.round(lerpState.bg.r);
            const bgG = Math.round(lerpState.bg.g);
            const bgB = Math.round(lerpState.bg.b);
            const bgLum = (bgR + bgG + bgB) / 3;
            
            document.body.style.backgroundColor = `rgb(${bgR}, ${bgG}, ${bgB})`;

            const prismFilter = prisms[prismMode].filter;
            const envFilter = `brightness(${lerpState.brightness}%) contrast(${lerpState.contrast}%)`;
            canvas.style.filter = `${prismFilter} ${envFilter}`.trim();

            const m = moods[currentMood];
            const trailAlpha = currentMood === 'rage' ? 0.35 : 0.18;
            
            ctx.fillStyle = `rgba(${bgR}, ${bgG}, ${bgB}, ${trailAlpha})`;
            ctx.fillRect(0, 0, width, height);

            if (m.connect) {
                const max2 = 10000; 
                ctx.beginPath();
                ctx.strokeStyle = m.color;
                
                // In Solar mode, make lines a bit more solid/darker
                ctx.shadowBlur = bgLum > 180 ? 0 : 10;
                ctx.shadowColor = m.color;
                if (bgLum > 180) ctx.strokeStyle = m.color; 

                const count = Math.min(m.count, particles.length);
                for (let i = 0; i < count; i++) {
                    for (let j = i + 1; j < count; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const d2 = dx*dx + dy*dy;
                        if (d2 < max2) {
                            const distFactor = (1 - Math.sqrt(d2)/100);
                            ctx.globalAlpha = bgLum > 180 ? distFactor * 0.4 : distFactor * 0.15;
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                        }
                    }
                }
                ctx.stroke();
                ctx.shadowBlur = 0; 
                ctx.globalAlpha = 1;
            }

            const activeCount = Math.min(m.count, particles.length);
            for (let i = 0; i < activeCount; i++) {
                particles[i].update(m);
                particles[i].draw(m);
            }
            requestAnimationFrame(animate);
        }

        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('resize', resize);
        
        resize();
        createUI();
        animate();
        updateStatusInfo();
    </script>
</body>
</html>
